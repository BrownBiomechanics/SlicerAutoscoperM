import logging
import os
from itertools import product

import numpy as np
import slicer
import vtk


def loadSegmentation(segmentationNode: slicer.vtkMRMLSegmentationNode, filename: str):
    """
    Load a segmentation file

    :param segmentationNode: Segmentation node
    :param filename: File name
    """
    # Get the extension
    extension = os.path.splitext(filename)[1]

    if extension == ".iv":  # Load this as an Open Inventor File
        modelNode = slicer.util.loadNodeFromFile(filename, "OpenInventorMesh")  # Requires SlicerSandBox extension
        # Import the model into the segmentation node
        slicer.modules.segmentations.logic().ImportModelToSegmentationNode(modelNode, segmentationNode)
        # Clean up
        slicer.mrmlScene.RemoveNode(modelNode)
        return None

    try:  # If the filetype is not known try to load it as a segmentation
        return slicer.util.loadSegmentation(filename)
    except Exception as e:
        logging.error(f"Could not load {filename} \n {e}")
        return None


def generateConfigFile(
    outputConfigPath: str,
    trialName: str,
    camCalFiles: list[str],
    camRootDirs: list[str],
    volumeFiles: list[str],
    volumeFlip: list[int],
    voxelSize: list[float],
    renderResolution: list[int],
    optimizationOffsets: list[float],
) -> None:
    """
    Generates the v1.1 config file for the trial

    :param outputConfigPath: The absolute path to the config file to be generated
    :param trialName: Trial name
    :param camCalFiles: The list of camera calibration file paths, relative to the main output dir
    :param camRootDirs: The list of the radiograph directory paths, relative to the main output dir
    :param volumeFiles: The list of tiff volume files, relative to the main output dir
    :param volumeFlip: The flip settings for each of the volumes
    :param voxelSize: The voxel size of each of the the volumes
    :param renderResolution: The resolution of the 2D rendering of each of the volumes
    :param optimizationOffsets: The offsets for the optimization

    :return: Path to the config file
    """
    import datetime

    with open(outputConfigPath, "w+") as f:
        # Trial Name as comment
        f.write(f"# {trialName} configuration file\n")
        f.write(
            "# This file was automatically generated by AutoscoperM on " + datetime.datetime.now().strftime("%c") + "\n"
        )
        f.write("\n")

        # Version of the cfg file
        f.write("Version 1.1\n")
        f.write("\n")

        # Camera Calibration Files
        f.write("# Camera Calibration Files\n")
        for calibrationFile in camCalFiles:
            f.write("mayaCam_csv " + calibrationFile + "\n")
        f.write("\n")

        # Camera Root Directories
        f.write("# Camera Root Directories\n")
        for cameraRootDir in camRootDirs:
            f.write("CameraRootDir " + cameraRootDir + "\n")
        f.write("\n")

        # Volumes
        f.write("# Volumes\n")
        for volume in volumeFiles:
            f.write("VolumeFile " + volume + "\n")
            f.write("VolumeFlip " + " ".join([str(x) for x in volumeFlip]) + "\n")
            f.write("VoxelSize " + " ".join([str(x) for x in voxelSize]) + "\n")
        f.write("\n")

        # Render Resolution
        f.write("# Render Resolution\n")
        f.write("RenderResolution " + " ".join([str(x) for x in renderResolution]) + "\n")
        f.write("\n")

        # Optimization Offsets
        f.write("# Optimization Offsets\n")
        f.write("OptimizationOffsets " + " ".join([str(x) for x in optimizationOffsets]) + "\n")
        f.write("\n")


def writeVolume(volumeNode: slicer.vtkMRMLVolumeNode, filename: str):
    """
    Writes a volumeNode to a file.

    :param volumeNode: Volume node
    :param filename: Output file name
    """
    slicer.util.exportNode(volumeNode, filename, {"useCompression": False}, world=True)


def castVolumeForTIFF(volumeNode: slicer.vtkMRMLVolumeNode):
    """
    Casts a volume node for writing to a TIFF file. This is necessary because Autoscoper
    only supports unsigned short TIFF stacks.

    :param volumeNode: Volume node
    """
    _castVolume(volumeNode, "Short")

    volumeArray = slicer.util.arrayFromVolume(volumeNode)
    minVal = np.min(volumeArray)
    if minVal < 0:
        minVal = -minVal
    isNotZero = volumeArray != 0  # Since 0 is the background value, we don't want to add minVal to it
    volumeArray[isNotZero] += minVal

    slicer.util.updateVolumeFromArray(volumeNode, volumeArray)

    _castVolume(volumeNode, "UnsignedShort")


def _castVolume(volumeNode: slicer.vtkMRMLVolumeNode, newType: str):
    """
    Internal function to cast a volume node to a new type
    """
    tmpVolNode = _createNewVolumeNode("tmpVolNode")
    castModule = slicer.modules.castscalarvolume
    parameters = {}
    parameters["InputVolume"] = volumeNode.GetID()
    parameters["OutputVolume"] = tmpVolNode.GetID()
    parameters["Type"] = newType  # Short to UnsignedShort
    cliNode = slicer.cli.runSync(castModule, None, parameters)
    slicer.mrmlScene.RemoveNode(cliNode)
    del cliNode, parameters, castModule

    volumeNode.SetAndObserveImageData(tmpVolNode.GetImageData())
    slicer.mrmlScene.RemoveNode(tmpVolNode)


def _createNewVolumeNode(nodeName: str) -> slicer.vtkMRMLVolumeNode:
    """
    Internal function to create a blank volume node
    """
    imageSize = [512, 512, 512]
    voxelType = vtk.VTK_UNSIGNED_CHAR
    imageOrigin = [0.0, 0.0, 0.0]
    imageSpacing = [1.0, 1.0, 1.0]
    imageDirections = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    fillVoxelValue = 0

    # Create an empty image volume, filled with fillVoxelValue
    imageData = vtk.vtkImageData()
    imageData.SetDimensions(imageSize)
    imageData.AllocateScalars(voxelType, 1)
    imageData.GetPointData().GetScalars().Fill(fillVoxelValue)
    # Create volume node
    volumeNode = slicer.mrmlScene.AddNewNodeByClass("vtkMRMLScalarVolumeNode", nodeName)
    volumeNode.SetOrigin(imageOrigin)
    volumeNode.SetSpacing(imageSpacing)
    volumeNode.SetIJKToRASDirections(imageDirections)
    volumeNode.SetAndObserveImageData(imageData)
    volumeNode.CreateDefaultDisplayNodes()
    return volumeNode


def writeTFMFile(filename: str, spacing: list[float], origin: list[float]):
    """
    Writes a TFM file

    :param filename: Output file name
    :param spacing: Spacing
    :param origin: Origin
    """

    tfm = vtk.vtkMatrix4x4()
    tfm.SetElement(0, 0, spacing[0])
    tfm.SetElement(1, 1, spacing[1])
    tfm.SetElement(2, 2, spacing[2])
    tfm.SetElement(0, 3, origin[0])
    tfm.SetElement(1, 3, origin[1])
    tfm.SetElement(2, 3, origin[2])

    transformNode = slicer.vtkMRMLLinearTransformNode()
    transformNode.SetMatrixTransformToParent(tfm)
    slicer.mrmlScene.AddNode(transformNode)

    slicer.util.exportNode(transformNode, filename)

    slicer.mrmlScene.RemoveNode(transformNode)


def writeTRA(fileName: str, transforms: list[vtk.vtkMatrix4x4]) -> None:
    rowWiseStrings = []
    for transform in transforms:
        rowWiseStrings.append([str(transform.GetElement(i, j)) for i, j in product(range(4), range(4))])
    with open(fileName, "w+") as traFile:
        for row in rowWiseStrings:
            traFile.write(",".join(row) + "\n")
